void testClassOnly ( ) { File file = ResourceManager . getSpringFile ( "config/MyConfiguration.java" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void getSpringFile ( ) { return getFile ( "code/spring/" + name ) ; }
void testWithAnnotations ( ) { File file = ResourceManager . getSpringFile ( "config/ConfigWithCurlyInAnnotation.java" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void getSpringFile ( ) { return getFile ( "code/spring/" + name ) ; }
assertTrue ( "WebMvcConfigurationSupport subclass failed." , SpringJavaConfigurationChecker . checkJavaFile ( file ) )
assertTrue ( "Failed to parse with curly braces in annotations." , SpringJavaConfigurationChecker . checkJavaFile ( file ) )

void typeConvertInputNotNullNotNullNotNullPositiveNotNullOutputPositive ( ) { final String tableName = "foo" ; final String columnName = "foo" ; final String value = "3" ; final int sqlType = 4 ; final String mysqlType = "foo" ; final Object actual = JdbcTypeUtil . typeConvert ( tableName , columnName , value , sqlType , mysqlType ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void typeConvert ( ) { if ( value == null || ( value . equals ( "" ) && ! ( isText ( mysqlType ) || sqlType == Types . CHAR || sqlType == Types . VARCHAR || sqlType == Types . LONGVARCHAR ) ) ) { return null ; } try { Object res ; switch ( sqlType ) { case Types . INTEGER : res = Integer . parseInt ( value ) ; break ; case Types . SMALLINT : res = Short . parseShort ( value ) ; break ; case Types . BIT : case Types . TINYINT : res = Byte . parseByte ( value ) ; break ; case Types . BIGINT : if ( mysqlType . startsWith ( "bigint" ) && mysqlType . endsWith ( "unsigned" ) ) { res = new BigInteger ( value ) ; } else { res = Long . parseLong ( value ) ; } break ; case Types . BOOLEAN : res = ! "0" . equals ( value ) ; break ; case Types . DOUBLE : case Types . FLOAT : res = Double . parseDouble ( value ) ; break ; case Types . REAL : res = Float . parseFloat ( value ) ; break ; case Types . DECIMAL : case Types . NUMERIC : res = new BigDecimal ( value ) ; break ; case Types . BINARY : case Types . VARBINARY : case Types . LONGVARBINARY : case Types . BLOB : res = value . getBytes ( "ISO-8859-1" ) ; break ; case Types . DATE : if ( ! value . startsWith ( "0000-00-00" ) ) { java . util . Date date = Util . parseDate ( value ) ; if ( date != null ) { res = new Date ( date . getTime ( ) ) ; } else { res = null ; } } else { res = null ; } break ; case Types . TIME : { java . util . Date date = Util . parseDate ( value ) ; if ( date != null ) { res = new Time ( date . getTime ( ) ) ; } else { res = null ; } break ; } case Types . TIMESTAMP : if ( ! value . startsWith ( "0000-00-00" ) ) { java . util . Date date = Util . parseDate ( value ) ; if ( date != null ) { res = new Timestamp ( date . getTime ( ) ) ; } else { res = null ; } } else { res = null ; } break ; case Types . CLOB : default : res = value ; break ; } return res ; } catch ( Exception e ) { logger . error ( "table: {} column: {}, failed convert type {} to {}" , tableName , columnName , value , sqlType ) ; return value ; } }
void typeConvertInputNotNullNotNullNotNullNegativeNotNullOutput3 ( ) { final String tableName = "foo" ; final String columnName = "foo" ; final String value = "foo" ; final int sqlType = - 4 ; final String mysqlType = "foo" ; final Object actual = JdbcTypeUtil . typeConvert ( tableName , columnName , value , sqlType , mysqlType ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void typeConvert ( ) { if ( value == null || ( value . equals ( "" ) && ! ( isText ( mysqlType ) || sqlType == Types . CHAR || sqlType == Types . VARCHAR || sqlType == Types . LONGVARCHAR ) ) ) { return null ; } try { Object res ; switch ( sqlType ) { case Types . INTEGER : res = Integer . parseInt ( value ) ; break ; case Types . SMALLINT : res = Short . parseShort ( value ) ; break ; case Types . BIT : case Types . TINYINT : res = Byte . parseByte ( value ) ; break ; case Types . BIGINT : if ( mysqlType . startsWith ( "bigint" ) && mysqlType . endsWith ( "unsigned" ) ) { res = new BigInteger ( value ) ; } else { res = Long . parseLong ( value ) ; } break ; case Types . BOOLEAN : res = ! "0" . equals ( value ) ; break ; case Types . DOUBLE : case Types . FLOAT : res = Double . parseDouble ( value ) ; break ; case Types . REAL : res = Float . parseFloat ( value ) ; break ; case Types . DECIMAL : case Types . NUMERIC : res = new BigDecimal ( value ) ; break ; case Types . BINARY : case Types . VARBINARY : case Types . LONGVARBINARY : case Types . BLOB : res = value . getBytes ( "ISO-8859-1" ) ; break ; case Types . DATE : if ( ! value . startsWith ( "0000-00-00" ) ) { java . util . Date date = Util . parseDate ( value ) ; if ( date != null ) { res = new Date ( date . getTime ( ) ) ; } else { res = null ; } } else { res = null ; } break ; case Types . TIME : { java . util . Date date = Util . parseDate ( value ) ; if ( date != null ) { res = new Time ( date . getTime ( ) ) ; } else { res = null ; } break ; } case Types . TIMESTAMP : if ( ! value . startsWith ( "0000-00-00" ) ) { java . util . Date date = Util . parseDate ( value ) ; if ( date != null ) { res = new Timestamp ( date . getTime ( ) ) ; } else { res = null ; } } else { res = null ; } break ; case Types . CLOB : default : res = value ; break ; } return res ; } catch ( Exception e ) { logger . error ( "table: {} column: {}, failed convert type {} to {}" , tableName , columnName , value , sqlType ) ; return value ; } }
Assert . assertEquals ( 3 , actual )
Assert . assertArrayEquals ( new byte [ ] { ( byte ) 102 , ( byte ) 111 , ( byte ) 111 } , ( ( byte [ ] ) actual ) )

void shouldBeConnectingIfAtLeastOneServiceConnectingOnConnect ( ) { ServiceRegistry registryMock = mock ( ServiceRegistry . class ) ; Service service1Mock = mock ( Service . class ) ; Service service2Mock = mock ( Service . class ) ; when ( registryMock . services ( ) ) . thenReturn ( new Service [ ] { service1Mock , service2Mock } ) ; when ( service1Mock . connect ( ) ) . thenReturn ( Observable . just ( LifecycleState . DISCONNECTED ) ) ; when ( service2Mock . connect ( ) ) . thenReturn ( Observable . just ( LifecycleState . CONNECTING ) ) ; CouchbaseNode node = new CouchbaseNode ( host , registryMock , ctx , ServiceFactory . INSTANCE ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>"
void shouldBeDisconnectedIfNoServiceConnectingOnConnect ( ) { ServiceRegistry registryMock = mock ( ServiceRegistry . class ) ; Service service1Mock = mock ( Service . class ) ; Service service2Mock = mock ( Service . class ) ; when ( registryMock . services ( ) ) . thenReturn ( new Service [ ] { service1Mock , service2Mock } ) ; when ( service1Mock . connect ( ) ) . thenReturn ( Observable . just ( LifecycleState . DISCONNECTED ) ) ; when ( service2Mock . connect ( ) ) . thenReturn ( Observable . just ( LifecycleState . DISCONNECTED ) ) ; CouchbaseNode node = new CouchbaseNode ( host , registryMock , ctx , ServiceFactory . INSTANCE ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>"
assertEquals ( LifecycleState . CONNECTING , node . connect ( ) . toBlocking ( ) . single ( ) )
assertEquals ( LifecycleState . DISCONNECTED , node . connect ( ) . toBlocking ( ) . single ( ) )

void preHandle_MethodFeatureTwo_OnlyOneActive ( ) { enableFeature ( TestFeatures . METHOD_FEATURE ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void enableFeature ( ) { repository . setFeatureState ( new FeatureState ( feature , true ) ) ; assertTrue ( manager . isActive ( feature ) ) ; }
void preHandle_ClassFeature_Active ( ) { enableFeature ( TestFeatures . CLASS_FEATURE ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void enableFeature ( ) { repository . setFeatureState ( new FeatureState ( feature , true ) ) ; assertTrue ( manager . isActive ( feature ) ) ; }
assertPrehandle ( "methodFeatureTwo" , false , METHOD_FEATURE_TWO_RESPONSE_STATUS )
assertPrehandle ( "classFeature" , true , HttpStatus . OK . value ( ) )

void testFailingUnchecked ( ) { Stats . reset ( ) ; FieldsProcessor p = new FieldsProcessor ( ) { @ Override public Object fieldFunction ( Event event , Object valuedestination ) throws ProcessorException { throw new UncheckedProcessorException ( event . buildException ( "Expected unchecked error" ) ) ; } @ Override public String getName ( ) { return null ; } } ; p . setDestination ( "${field}_done" ) ; p . setFields ( new String [ ] { "a" , "b" } ) ; Event e = Tools . getEvent ( ) ; e . put ( "a" , 1 ) ; e . put ( "b" , 2 ) ; Tools . runProcessing ( e , "main" , Collections . singletonList ( p ) ) ; long found = Stats . getErrors ( ) . stream ( ) . map ( i -> ( Throwable ) i ) . map ( Throwable :: getMessage ) . filter ( i -> Pattern . matches ( "Field with path \"\\[.\\]\" invalid: Expected unchecked error" , i ) ) . count ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>"
void testFailing ( ) { Stats . reset ( ) ; FieldsProcessor p = new FieldsProcessor ( ) { @ Override public Object fieldFunction ( Event event , Object valuedestination ) throws ProcessorException { throw event . buildException ( "Expected error" ) ; } @ Override public String getName ( ) { return null ; } } ; p . setDestination ( "${field}_done" ) ; p . setFields ( new String [ ] { "a" , "b" } ) ; Event e = Tools . getEvent ( ) ; e . put ( "a" , 1 ) ; e . put ( "b" , 2 ) ; Tools . runProcessing ( e , "main" , Collections . singletonList ( p ) ) ; long found = Stats . getErrors ( ) . stream ( ) . map ( i -> ( Throwable ) i ) . map ( Throwable :: getMessage ) . filter ( i -> Pattern . matches ( "Field with path \"\\[.\\]\" invalid: Expected error" , i ) ) . count ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>"
Assert . assertEquals ( 1 , found )
Assert . assertEquals ( 1 , found )

void testSetTime ( ) { Time t = new Time ( 1 , 2 , 3.456 ) ; gga . setTime ( t ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setTime ( ) { setStringValue ( UTC_TIME , t . toString ( ) ) ; }
void testSetTime ( ) { Time t = new Time ( 1 , 2 , 3.45 ) ; ttm . setTime ( t ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setTime ( ) { String str = String . format ( "%02d%02d" , t . getHour ( ) , t . getMinutes ( ) ) ; DecimalFormat nf = new DecimalFormat ( "00.00" ) ; DecimalFormatSymbols dfs = new DecimalFormatSymbols ( ) ; dfs . setDecimalSeparator ( '.' ) ; nf . setDecimalFormatSymbols ( dfs ) ; str += nf . format ( t . getSeconds ( ) ) ; setStringValue ( UTC_TIME , str ) ; }
assertTrue ( gga . toString ( ) . contains ( "GPGGA,010203.456,6011" ) )
assertTrue ( ttm . toString ( ) . contains ( ",010203.45," ) )

void intialize_map ( ) { Map < String , String > newMap = Maps . newHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>"
void map_has_hasValue ( ) { Map < String , String > breeds = Maps . newHashMap ( ) ; breeds . put ( "labrador" , "buzz" ) ; breeds . put ( "dachshund" , "gypsy" ) ; breeds . put ( "boxer" , "buddy" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>"
assertNotNull ( newMap )
assertThat ( breeds , hasValue ( "gypsy" ) )

void testGetTopTermThesaurusConcepts ( ) { List < ThesaurusConcept > list = new ArrayList < ThesaurusConcept > ( ) ; ThesaurusConcept co1 = new ThesaurusConcept ( ) ; co1 . setIdentifier ( "co1" ) ; list . add ( co1 ) ; when ( thesaurusConceptDAO . getTopTermThesaurusConcept ( any ( Thesaurus . class ) , eq ( 0 ) , anyString ( ) ) ) . thenReturn ( list ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>"
void getResourcesShouldUseProjectNameForNamespaceWhenGettingResources ( ) { ArrayList < IService > services = new ArrayList < IService > ( ) ; when ( client . < IService > list ( eq ( ResourceKind . SERVICE ) , anyString ( ) ) ) . thenReturn ( services ) ; List < IService > resources = project . getResources ( ResourceKind . SERVICE ) ; "<AssertPlaceHolder>" ; verify ( client ) . list ( eq ( ResourceKind . SERVICE ) , eq ( project . getName ( ) ) ) ; } "<FocalMethod>"
Assert . assertNotNull ( "Not null list expected" , thesaurusConceptDAO . getTopTermThesaurusConcept ( any ( Thesaurus . class ) , eq ( 0 ) , anyString ( ) ) )
assertEquals ( "Exp. a list of services" , services , resources )

void shouldFailIfTooFewValues ( ) { final MapContract map = MapContract . builder ( IdentityMap . class ) . name ( "Map" ) . build ( ) ; TestPlan testPlan = new TestPlan ( map ) ; testPlan . getInput ( ) . add ( new PactInteger ( 1 ) , new PactString ( "test1" ) ) . add ( new PactInteger ( 2 ) , new PactString ( "test2" ) ) ; testPlan . getExpectedOutput ( PactInteger . class , PactString . class ) . add ( new PactInteger ( 1 ) , new PactString ( "test1" ) ) . add ( new PactInteger ( 2 ) , new PactString ( "test2" ) ) . add ( new PactInteger ( 3 ) , new PactString ( "test3" ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void PactString ( ) { this . value = EMPTY_STRING ; setValue ( value ) ; }
void shouldFailWithEqualValuesWithSameKey ( ) { final MapContract map = MapContract . builder ( IdentityMap . class ) . name ( "Map" ) . build ( ) ; TestPlan testPlan = new TestPlan ( map ) ; testPlan . getInput ( ) . add ( new PactInteger ( 1 ) , new PactString ( "test1" ) ) . add ( new PactInteger ( 1 ) , new PactString ( "test2" ) ) . add ( new PactInteger ( 1 ) , new PactString ( "test3" ) ) . add ( new PactInteger ( 2 ) , new PactString ( "test1" ) ) . add ( new PactInteger ( 2 ) , new PactString ( "test2" ) ) . add ( new PactInteger ( 2 ) , new PactString ( "test3" ) ) ; testPlan . getExpectedOutput ( PactInteger . class , PactString . class ) . add ( new PactInteger ( 1 ) , new PactString ( "test1" ) ) . add ( new PactInteger ( 2 ) , new PactString ( "test1" ) ) . add ( new PactInteger ( 2 ) , new PactString ( "test2" ) ) . add ( new PactInteger ( 1 ) , new PactString ( "test3" ) ) . add ( new PactInteger ( 1 ) , new PactString ( "test3" ) ) . add ( new PactInteger ( 2 ) , new PactString ( "test3" ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void PactString ( ) { this . value = EMPTY_STRING ; setValue ( value ) ; }
assertTestRunFails ( testPlan )
assertTestRunFails ( testPlan )

void testNameAndBlankVersion ( ) { final PropertyValue nameValue = new MockPropertyValue ( "person" ) ; final PropertyValue branchValue = new MockPropertyValue ( null ) ; final PropertyValue versionValue = new MockPropertyValue ( "   " ) ; final SchemaNamePropertyStrategy schemaNamePropertyStrategy = new SchemaNamePropertyStrategy ( schemaRegistry , nameValue , branchValue , versionValue ) ; final SchemaIdentifier expectedSchemaIdentifier = SchemaIdentifier . builder ( ) . name ( nameValue . getValue ( ) ) . build ( ) ; when ( schemaRegistry . retrieveSchema ( argThat ( new SchemaIdentifierMatcher ( expectedSchemaIdentifier ) ) ) ) . thenReturn ( recordSchema ) ; final RecordSchema retrievedSchema = schemaNamePropertyStrategy . getSchema ( Collections . emptyMap ( ) , null , recordSchema ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>"
void testNameAndVersion ( ) { final PropertyValue nameValue = new MockPropertyValue ( "person" ) ; final PropertyValue branchValue = new MockPropertyValue ( null ) ; final PropertyValue versionValue = new MockPropertyValue ( "1" ) ; final SchemaNamePropertyStrategy schemaNamePropertyStrategy = new SchemaNamePropertyStrategy ( schemaRegistry , nameValue , branchValue , versionValue ) ; final SchemaIdentifier expectedSchemaIdentifier = SchemaIdentifier . builder ( ) . name ( nameValue . getValue ( ) ) . version ( versionValue . asInteger ( ) ) . build ( ) ; when ( schemaRegistry . retrieveSchema ( argThat ( new SchemaIdentifierMatcher ( expectedSchemaIdentifier ) ) ) ) . thenReturn ( recordSchema ) ; final RecordSchema retrievedSchema = schemaNamePropertyStrategy . getSchema ( Collections . emptyMap ( ) , null , recordSchema ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>"
assertNotNull ( retrievedSchema )
assertNotNull ( retrievedSchema )

