void testIntProperty ( ) { bean = new TestBean ( ) ; ObjectUtils . setBeanProperty ( bean , "int-property" , "25" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setBeanProperty ( ) { prop = makePropertyName ( prop ) ; try { boolean found = false ; Method [ ] methods = object . getClass ( ) . getMethods ( ) ; for ( int ix = 0 ; ix < methods . length && ! found ; ix ++ ) { if ( ! methods [ ix ] . getName ( ) . equals ( prop ) ) continue ; if ( methods [ ix ] . getParameterTypes ( ) . length != 1 ) continue ; Class type = methods [ ix ] . getParameterTypes ( ) [ 0 ] ; methods [ ix ] . invoke ( object , convertToType ( value , type ) ) ; found = true ; } if ( ! found ) throw new DukeConfigException ( "Couldn't find method '" + prop + "' in " + "class " + object . getClass ( ) ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } catch ( InvocationTargetException e ) { throw new RuntimeException ( e ) ; } }
void testDoubleProperty ( ) { bean = new TestBean ( ) ; ObjectUtils . setBeanProperty ( bean , "double-property" , "0.25" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setBeanProperty ( ) { prop = makePropertyName ( prop ) ; try { boolean found = false ; Method [ ] methods = object . getClass ( ) . getMethods ( ) ; for ( int ix = 0 ; ix < methods . length && ! found ; ix ++ ) { if ( ! methods [ ix ] . getName ( ) . equals ( prop ) ) continue ; if ( methods [ ix ] . getParameterTypes ( ) . length != 1 ) continue ; Class type = methods [ ix ] . getParameterTypes ( ) [ 0 ] ; methods [ ix ] . invoke ( object , convertToType ( value , type ) ) ; found = true ; } if ( ! found ) throw new DukeConfigException ( "Couldn't find method '" + prop + "' in " + "class " + object . getClass ( ) ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } catch ( InvocationTargetException e ) { throw new RuntimeException ( e ) ; } }
assertEquals ( "property not set correctly" , 25 , bean . getIntProperty ( ) )
assertEquals ( "property not set correctly" , 0.25 , bean . getDoubleProperty ( ) )

void testSimpleBitSet ( ) { WrappedBitSetBitmap bitSet = new WrappedBitSetBitmap ( IntSetTestUtility . createSimpleBitSet ( IntSetTestUtility . getSetBits ( ) ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void getSetBits ( ) { return Sets . newTreeSet ( setBits ) ; }
void testSize ( ) { BitSet bitSet = IntSetTestUtility . createSimpleBitSet ( IntSetTestUtility . getSetBits ( ) ) ; WrappedBitSetBitmap wrappedBitSetBitmapBitSet = new WrappedBitSetBitmap ( bitSet ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void getSetBits ( ) { return Sets . newTreeSet ( setBits ) ; }
Assert . assertTrue ( IntSetTestUtility . equalSets ( IntSetTestUtility . getSetBits ( ) , bitSet ) )
Assert . assertEquals ( bitSet . cardinality ( ) , wrappedBitSetBitmapBitSet . size ( ) )

void faultsShouldBeHandledWithoutMessageInteraction ( ) { "<AssertPlaceHolder>" ; verify ( message , never ( ) ) . getSOAPHeader ( ) ; } "<FocalMethod>"
void testGetDelegateConnectionParameters ( ) { "<AssertPlaceHolder>" ; verify ( httpURLConnection ) . setRequestProperty ( "Accepts" , contentType ) ; } "<FocalMethod>"
assertThat ( unit . handleFault ( messageContext ) , is ( true ) )
assertEquals ( httpURLConnection , delegatingConfigurationProvider . getDelegateConnection ( contentType , parameters ) )

void testInequalityToNull ( ) { Point p1 = point ( 1 , 2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void point ( ) { return Point . create ( x , y , 0 ) ; }
void testInequalityToNull ( ) { Point p1 = Geometries . point ( 1 , 2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void point ( ) { return PointFloat . create ( x , y ) ; }
assertFalse ( p1 . equals ( null ) )
assertFalse ( p1 . equals ( null ) )

void shouldValidateUserThatIsNotGuest ( ) { when ( userId . isGuest ( ) ) . thenReturn ( false ) ; RequestValidationResult result = validator . validateAction ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void validateAction ( ) { if ( userId . isGuest ( ) ) { return RequestValidationResult . getInvalid ( "You must be signed in to perform this operation.  Please sign in." ) ; } else { return RequestValidationResult . getValid ( ) ; } }
void shouldNoValidateUserThatIsGuest ( ) { when ( userId . isGuest ( ) ) . thenReturn ( true ) ; RequestValidationResult result = validator . validateAction ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void validateAction ( ) { if ( userId . isGuest ( ) ) { return RequestValidationResult . getInvalid ( "You must be signed in to perform this operation.  Please sign in." ) ; } else { return RequestValidationResult . getValid ( ) ; } }
assertThat ( result . isValid ( ) , is ( true ) )
assertThat ( result . isValid ( ) , is ( false ) )

void captureOn2_2 ( ) { final int [ ] [ ] [ ] board = { { { 2 , 1 } , { 2 , 1 } , { 0 , 0 } , { 2 , 2 } , { 0 , 0 } } , { { 2 , 2 } , { 2 , 3 } , { 2 , 3 } , { 2 , 3 } , { 2 , 2 } } , { { 1 , 1 } , { 0 , 0 } , { 1 , 3 } , { 1 , 1 } , { 2 , 1 } } , { { 1 , 2 } , { 1 , 1 } , { 1 , 3 } , { 0 , 0 } , { 0 , 0 } } , { { 1 , 1 } , { 1 , 2 } , { 1 , 2 } , { 2 , 1 } , { 2 , 1 } } } ; MinMax minMax = new MinMax ( ) ; "<AssertPlaceHolder>" ; System . out . println ( minMax . eval + " " + minMax . depth + " " + minMax . moves + " " + minMax . computations ) ; } "<FocalMethod>"
void centralBlockShouldBeFilled ( ) { final int [ ] [ ] [ ] board = { { { 0 , 0 } , { 0 , 0 } , { 0 , 0 } , { 0 , 0 } , { 0 , 0 } } , { { 0 , 0 } , { 0 , 0 } , { 0 , 0 } , { 2 , 1 } , { 0 , 0 } } , { { 0 , 0 } , { 0 , 0 } , { 2 , 1 } , { 1 , 3 } , { 2 , 1 } } , { { 0 , 0 } , { 0 , 0 } , { 0 , 0 } , { 2 , 1 } , { 0 , 0 } } , { { 0 , 0 } , { 0 , 0 } , { 0 , 0 } , { 0 , 0 } , { 0 , 0 } } } ; MinMax minMax = new MinMax ( ) ; "<AssertPlaceHolder>" ; System . out . println ( minMax . eval + " " + minMax . depth + " " + minMax . moves + " " + minMax . computations ) ; } "<FocalMethod>"
assertThat ( minMax . iterativeSearchForBestMove ( board , 1 ) , anyOf ( containsString ( "2 2" ) , containsString ( "0 3" ) , containsString ( "4 0" ) , containsString ( "4 1" ) , containsString ( "4 2" ) , containsString ( "3 0" ) , containsString ( "3 2" ) ) )
assertEquals ( "2 3" , minMax . iterativeSearchForBestMove ( board , 1 ) )

void halvesConnectionsOnBackoff ( ) { connPerRoute . setMaxPerRoute ( route , 4 ) ; impl . backOff ( route ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void backOff ( ) { synchronized ( connPerRoute ) { final int curr = connPerRoute . getMaxPerRoute ( route ) ; final Long lastUpdate = getLastUpdate ( lastRouteBackoffs , route ) ; final long now = clock . getCurrentTime ( ) ; if ( now - lastUpdate . longValue ( ) < coolDown . toMilliseconds ( ) ) { return ; } connPerRoute . setMaxPerRoute ( route , getBackedOffPoolSize ( curr ) ) ; lastRouteBackoffs . put ( route , Long . valueOf ( now ) ) ; } }
void doesNotBackoffBelowOneConnection ( ) { connPerRoute . setMaxPerRoute ( route , 1 ) ; impl . backOff ( route ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void backOff ( ) { synchronized ( connPerRoute ) { final int curr = connPerRoute . getMaxPerRoute ( route ) ; final Long lastUpdate = getLastUpdate ( lastRouteBackoffs , route ) ; final long now = clock . getCurrentTime ( ) ; if ( now - lastUpdate . longValue ( ) < coolDown . toMilliseconds ( ) ) { return ; } connPerRoute . setMaxPerRoute ( route , getBackedOffPoolSize ( curr ) ) ; lastRouteBackoffs . put ( route , Long . valueOf ( now ) ) ; } }
assertEquals ( 2 , connPerRoute . getMaxPerRoute ( route ) )
assertEquals ( 1 , connPerRoute . getMaxPerRoute ( route ) )

void testOverrideMeanWithMathClass ( ) { double [ ] scores = { 1 , 2 , 3 , 4 } ; SummaryStatistics stats = new SummaryStatistics ( ) ; stats . setMeanImpl ( new Mean ( ) ) ; for ( double i : scores ) { stats . addValue ( i ) ; } "<AssertPlaceHolder>" ; } "<FocalMethod>" void addValue ( ) { sumImpl . increment ( value ) ; sumsqImpl . increment ( value ) ; minImpl . increment ( value ) ; maxImpl . increment ( value ) ; sumLogImpl . increment ( value ) ; secondMoment . increment ( value ) ; if ( meanImpl != mean ) { meanImpl . increment ( value ) ; } if ( varianceImpl != variance ) { varianceImpl . increment ( value ) ; } if ( geoMeanImpl != geoMean ) { geoMeanImpl . increment ( value ) ; } n ++ ; }
void testOverrideGeoMeanWithMathClass ( ) { double [ ] scores = { 1 , 2 , 3 , 4 } ; SummaryStatistics stats = new SummaryStatistics ( ) ; stats . setGeoMeanImpl ( new GeometricMean ( ) ) ; for ( double i : scores ) { stats . addValue ( i ) ; } "<AssertPlaceHolder>" ; } "<FocalMethod>" void addValue ( ) { sumImpl . increment ( value ) ; sumsqImpl . increment ( value ) ; minImpl . increment ( value ) ; maxImpl . increment ( value ) ; sumLogImpl . increment ( value ) ; secondMoment . increment ( value ) ; if ( meanImpl != mean ) { meanImpl . increment ( value ) ; } if ( varianceImpl != variance ) { varianceImpl . increment ( value ) ; } if ( geoMeanImpl != geoMean ) { geoMeanImpl . increment ( value ) ; } n ++ ; }
Assert . assertEquals ( ( new Mean ( ) ) . evaluate ( scores ) , stats . getMean ( ) , 0 )
Assert . assertEquals ( ( new GeometricMean ( ) ) . evaluate ( scores ) , stats . getGeometricMean ( ) , 0 )

void testMessagesWithoutText ( ) { List < FacesMessage > existingFacesMessage = new ArrayList < FacesMessage > ( ) ; existingFacesMessage . add ( new FacesMessage ( null , null ) ) ; FacesMessage messageToCheck = new FacesMessage ( null , null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>"
void shouldSortPluginsWithNoDependency ( ) { given ( pluginAccessor . getPlugin ( "testPlugin1" ) ) . willReturn ( plugin1 ) ; given ( pluginAccessor . getPlugin ( "testPlugin2" ) ) . willReturn ( plugin2 ) ; given ( pluginAccessor . getPlugin ( "testPlugin3" ) ) . willReturn ( plugin3 ) ; given ( pluginAccessor . getPlugin ( "testPlugin4" ) ) . willReturn ( plugin4 ) ; List < Plugin > argumentPlugins = new ArrayList < Plugin > ( ) ; argumentPlugins . add ( plugin4 ) ; argumentPlugins . add ( plugin1 ) ; argumentPlugins . add ( plugin2 ) ; argumentPlugins . add ( plugin3 ) ; List < Plugin > sortedPlugins = manager . sortPluginsInDependencyOrder ( argumentPlugins ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void sortPluginsInDependencyOrder ( ) { return sortPluginsInDependencyOrder ( plugins , null ) ; }
Assert . assertEquals ( Boolean . FALSE , JsfUtils . isNewMessage ( existingFacesMessage , messageToCheck ) )
assertEquals ( 4 , sortedPlugins . size ( ) )

void testXMLRawDispatchPullCalls ( ) { m_test1 = ServiceFactory . create ( ADMIN_NAME , "remote" , serverUri . toURL ( ) , true ) ; byte [ ] param = XML_RAW_MESSAGE . getBytes ( ) ; debug ( "Raw request: " + new String ( param ) ) ; ByteBufferWrapper inParam = new ByteBufferWrapper ( ) ; inParam . setByteBuffer ( ByteBuffer . wrap ( param ) ) ; ByteBufferWrapper outParam = new ByteBufferWrapper ( ) ; InvokerExchange exchange = new InvokerExchange ( m_headers , inParam , outParam ) ; Response < ? > resp = m_test1 . createDispatch ( "echoString" , true ) . invokeAsync ( exchange ) ; resp . get ( ) ; ByteBuffer outBuffer = outParam . getByteBuffer ( ) ; String xmlResponse = new String ( outBuffer . array ( ) ) ; debug ( "XML Raw response: " + xmlResponse ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void debug ( ) { logger . debug ( msg ) ; }
void testXMLRawDispatchPushCalls ( ) { m_test1 = ServiceFactory . create ( ADMIN_NAME , "remote" , serverUri . toURL ( ) , true ) ; byte [ ] param = XML_RAW_MESSAGE . getBytes ( ) ; debug ( "Raw request: " + new String ( param ) ) ; ByteBufferWrapper inParam = new ByteBufferWrapper ( ) ; inParam . setByteBuffer ( ByteBuffer . wrap ( param ) ) ; ByteBufferWrapper outParam = new ByteBufferWrapper ( ) ; InvokerExchange exchange = new InvokerExchange ( m_headers , inParam , outParam ) ; Handler handler = new Handler ( ) ; Future < ? > status = m_test1 . createDispatch ( "echoString" , true ) . invokeAsync ( exchange , handler ) ; while ( ! status . isDone ( ) ) { Thread . sleep ( 200 ) ; } ByteBuffer outBuffer = outParam . getByteBuffer ( ) ; String xmlResponse = new String ( outBuffer . array ( ) ) ; debug ( "XML Raw response: " + xmlResponse ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void debug ( ) { logger . debug ( msg ) ; }
XmlAssert . assertEquals ( EXPECTED_XML_RESPONSE , xmlResponse )
XmlAssert . assertEquals ( EXPECTED_XML_RESPONSE , xmlResponse )

